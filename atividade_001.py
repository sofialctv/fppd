# -*- coding: utf-8 -*-
"""FundamentosPP_D_01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15u50oDFl1LfK2U8LT1_HSDJ9J4s1UhMr

**Aula 2**

Após nossa primeira aula, onde discutimos os fundamentos da programação paralela, vamos relembrar conceitos de Programação concorrente.

# *Atividade 1*
Vamos relembrar o uso de threads

#**1.A**
Um programa só com a thread principal.
"""

#1. Definindo  o código a ser executado neste código, sincronamente.
#importando bibliotecas necessárias
import time
from threading import Thread

def task(sec):
  print('Starting Task:')
  time.sleep(sec)
  print('Done')

# Medindo o Tempo de Execução
start=time.time()

task(3)

end=time.time()

print( f'Tempo decorrido:{end-start}')

"""#**1.B**
Agora vamos  ver como seria um programa com  apenas a thread principal chamando a mesma tarefa múltiplas vezes
"""

#importando bibliotecas necessárias
import time
from threading import Thread
def task(sec):
  print('Starting Task...')
  time.sleep(sec)
  print('Done!')


start=time.time()

for _ in range(5):
   task(1)

end=time.time()

print( f'Tempo decorrido:{end-start}')

"""#**1.C**
Agora vamos tirar proveito  de  núcleos com multithreads.
"""

#importando bibliotecas necessárias
import time
from threading import Thread
# Agora sim com múltiplas  Threads.
def task(sec):
  print('Doing Something...')
  time.sleep(sec)
  print('Done!')


start=time.time()

for _ in range(5):
   new_thread = Thread(target=task, args=[1])
   new_thread.start()


end=time.time()

print( f'Tempo decorrido:{end-start}')

"""#Ops!! Algo estranho, não?#

#**1.D**

Vamos pedir que o processo que contenha as threads só termine quando todas as threads terminarem
"""

#importando bibliotecas necessárias
import time
from threading import Thread
# Agora sim com múltiplas  Threads.
def do_something(sec):
  print('Doing Something...')
  time.sleep(sec)
  print('Done!')

threads=[]
start=time.time()

for _ in range(5):
   new_thread = Thread(target=do_something, args=[1])
   threads.append(new_thread)
   new_thread.start()

for t in threads:
  t.join()



end=time.time()

print( f'Tempo decorrido:{end-start}')

"""#**1.E**

Vamos encontrar o limite onde aumentando o número de threads  o tempo de conclusão fica maior que o tempo da Atividade  **1.B**
"""

# Agora sim com múltiplas  Threads.
#importando bibliotecas necessárias
import time
from threading import Thread
def do_something(sec):
  time.sleep(sec)
  return 'Done!'


threads=[]
start=time.time()

for _ in range(1000):
   new_thread = Thread(target=do_something, args=[1])
   threads.append(new_thread)
   new_thread.start()

for t in threads:
  t.join()



end=time.time()

print( f'Tempo decorrido:{end-start}')

"""# *Atividade 2* #
Vamos entender os fundamentos do paralelismo.
Temos que pensar em como dividir o problema e qual deve ser a atividade final para o resultado correto.

**2.A**

Estabelecendo o Benchmark
"""

# Criando o Vetor
import numpy as np
lista= np.random.randint(0, high=5000000,size=5000000)

import time
from threading import Thread,Lock
start=time.time()
meu_arr_ordenado = np.sort(lista) # cria um arranjo ordenado em ordem decrescente

end=time.time()
print(meu_arr_ordenado)
print( f'Tempo decorrido:{end-start}')

def quicksort_thread(start_idx, end_idx, arr, result, idx):
    part = arr[start_idx:end_idx]
    result[idx] = np.sort(part)  # Usando np.sort() que é quicksort por padrão

# Função para mesclar dois vetores ordenados
def merge(arr1, arr2):
    result = []
    i, j = 0, 0
    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            result.append(arr1[i])
            i += 1
        else:
            result.append(arr2[j])
            j += 1
    result.extend(arr1[i:])
    result.extend(arr2[j:])
    print
    return result

# Função para mesclar múltiplos vetores ordenados
def multi_merge(parts):
    while len(parts) > 1:
        merged_parts = []
        for i in range(0, len(parts), 2):
            if i + 1 < len(parts):
                merged_parts.append(merge(parts[i], parts[i+1]))
            else:
                merged_parts.append(parts[i])
        parts = merged_parts
    return parts[0]

# Iniciando o cronômetro
start = time.time()

# Definindo o número de threads
num_threads = 4
part_size = len(lista) // num_threads

# Lista para armazenar os resultados das threads
result = [None] * num_threads

# Criando as threads
threads = []
for i in range(num_threads):
    start_idx = i * part_size
    # Garantir que a última parte pegue até o final do vetor
    end_idx = (i + 1) * part_size if i != num_threads - 1 else len(lista)
    thread = Thread(target=quicksort_thread, args=(start_idx, end_idx, lista, result, i))
    threads.append(thread)
    thread.start()

# Esperando as threads terminarem
for thread in threads:
    thread.join()

# Mesclando as partes ordenadas
final_result = multi_merge(result)
# Finalizando o cronômetro
end = time.time()

# Exibindo o vetor ordenado e o tempo de execução
print(final_result)  # Aqui imprimimos o vetor final ordenado
print(f'Tempo decorrido com Quicksort paralelo: {end - start}')

import time
from threading import Thread,Lock

result=0
start=time.time()
for i in lista:
  result+=i

print("O resultado final  é:{}".format(result))
end=time.time()

print( f'Tempo decorrido:{end-start}')

"""#**2.B**#
Agora vamos  usar a programação multithreading e ver  se ganhamos tempo
"""

import time
import threading
lock=threading.Lock()
threads = []
result = 0
n_threads = 4

bloco = len(lista) // n_threads

def task(lst,idx, inic, fin):
    print('{0} - Somando minha parte: de {1} a {2}'.format(idx, inic, fin))
    # usando uma variável global para acumular o resultado final
    minhasoma=0
    global result

    for i in lst[inic:fin]:
        minhasoma+=i
    print('{0} - Done! Minha soma: {1}'.format(idx, minhasoma))
    with lock:  # Usando 'with' para gerenciar o lock
        result += minhasoma

start = time.time()

for x in range(n_threads):
    inicio = x * bloco
    final = inicio + bloco if x < n_threads - 1 else len(lista)  # Último bloco pode ser maior
    new_thread = threading.Thread(target=task, args=(lista,x, inicio, final))
    threads.append(new_thread)
    new_thread.start()

for t in threads:
    t.join()

print("O resultado final é: {0}".format(result))
end = time.time()

print(f'Tempo decorrido: {end - start:.4f} segundos')

"""# * 2.C*#
Será que removerndo o sincronismo lock o tempo melhora?
"""

import time
import threading
import numpy as np

threads = []
n_threads = 4
result = np.zeros(n_threads)
bloco = len(lista) // n_threads

def task(lst,idx, inic, fin):
    print('{0} - Somando minha parte: de {1} a {2}'.format(idx, inic, fin))
    # usando uma variável global para acumular o resultado final
    minhasoma=0
    global result

    for i in lst[inic:fin]:
        minhasoma+=i
    print('{0} - Done! Minha soma: {1}'.format(idx, minhasoma))
    result[idx]= minhasoma

start = time.time()

for x in range(n_threads+1):
    inicio = x * bloco
    final = inicio + bloco -1 if x < n_threads else len(lista)  # Último bloco pode ser maior
    new_thread = threading.Thread(target=task, args=(lista,x, inicio, final))
    threads.append(new_thread)
    new_thread.start()

for t in threads:
    t.join()

print("O resultado final é: {0}".format(np.sum(result)))
end = time.time()

print(f'Tempo decorrido: {end - start:.4f} segundos')

"""elaborar um programa paralelo em nível de thread que calcule a soma dos quadrados dos ele"""

# Elabore um programa paralelo em nivel de thread que calcule a soma dos quadrados dos elementos do vetor **vet** compara a versao serial com a paralela com 4 threads


import numpy as np
import time

np.random.seed(42)
vet = np.random.randint(0, high=1000000, size=1000000)
soma = 0

start = time.time()
for i in range(len(vet)):
  soma += vet[0]**2

end = time.time()
print(soma)
print("tempo decorido: " + str(end-start) + " segundos")

import numpy as np
import time
import threading

threads = []
n_threads = 4
result = 0
indice = 0

np.random.seed(42)
vet = np.random.randint(0, high=1000000, size=1000000)

start = time.time()

def task():
  global result
  global indice
  global vet
  with threading.Lock():
    while indice < len(vet):
        result += vet[indice]**2
        indice += 1

for i in range(n_threads):
  new_thread = threading.Thread(target=task)
  threads.append(new_thread)
  new_thread.start()

for t in threads:
    t.join()

end = time.time()
print(result)
print("tempo decorido: " + str(end-start) + " segundos")