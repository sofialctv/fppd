# -*- coding: utf-8 -*-
"""FPPD_03.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c7VCVjB_CEoId0lVEERdnJy6LfHTSbBb

# *Atividade 2*
Vamos fazer  uso de processos

# **2.A**
Criação manual de processos e exibição  de seus PIDS
"""

# importing the multiprocessing module
import multiprocessing
import os
import time

def worker1():
	# printing process id
	print("ID of process running worker1: {}".format(os.getpid()))

def worker2():
	# printing process id
	print("ID of process running worker2: {}".format(os.getpid()))

if __name__ == "__main__":
	# printing main program process id
	print("ID of main process: {}".format(os.getpid()))

	# creating processes
	p1 = multiprocessing.Process(target=worker1)
	p2 = multiprocessing.Process(target=worker2)

	# starting processes
	p1.start()
	p2.start()

	# process IDs
	print("ID of process p1: {}".format(p1.pid))
	print("ID of process p2: {}".format(p2.pid))

	# wait until processes are finished
	p1.join()
	p2.join()

	# both processes finished
	print("Both processes finished execution!")

	# check if processes are alive
	print("Process p1 is alive: {}".format(p1.is_alive()))
	print("Process p2 is alive: {}".format(p2.is_alive()))

"""# **2.B**#
Verificando a *independência* de Memória entre processos
"""

import multiprocessing
import os

# empty list with global scope
result = []

def square_list(mylist):
	"""
	function to square a given list
	"""
	global result
	# append squares of mylist to global list result
	for num in mylist:
		result.append(num * num)
	# print global list result
	print("Result(in process p1): {}".format(result))

if __name__ == "__main__":
	  # input list
	  mylist = [1,2,3,4]

	  # creating new process
	  p1 = multiprocessing.Process(target=square_list, args=(mylist,))
	  # starting process
	  p1.start()
	  print("PID:{}".format(p1.pid))
	  # wait until process is finished
	  p1.join()

	  # print global result list
	  print("Result(in main program): {}".format(result))

"""#**2.C**

Como fazer os processos compartilharem alguma área de memória?

"""

import multiprocessing

def square_list(mylist, result, square_sum):
	"""
	function to square a given list
	"""
	# append squares of mylist to result array
	for idx, num in enumerate(mylist):
		result[idx] = num * num

	# square_sum value
	square_sum.value = sum(result)

	# print result Array
	print("Result(in process p1): {}".format(result[:]))

	# print square_sum Value
	print("Sum of squares(in process p1): {}".format(square_sum.value))

if __name__ == "__main__":
	# input list
	mylist = [1,2,3,4]

	# creating Array of int data type with space for 4 integers Memória Compartilhada Solicitada ao SO
	result = multiprocessing.Array('i', 4)

	# creating Value of int data type
	square_sum = multiprocessing.Value('i')

	# creating new process
	p1 = multiprocessing.Process(target=square_list, args=(mylist, result, square_sum))

	# starting process
	p1.start()

	# wait until the process is finished
	p1.join()

	# print result array
	print("Result(in main program): {}".format(result[:]))

	# print square_sum Value
	print("Sum of squares(in main program): {}".format(square_sum.value))

"""**Atividade 3**

Agora compare o tempo de processamento  entre um sistema com 3 threads e um com 3 processos.
"""

# Código pra Thread

import time
from threading import Thread
# função a ser executada tanto pela tread quanto pelo processo
def do_something(sec):
  print('Doing Something...')
  time.sleep(sec)
  print('Done!')

executables=[]
start=time.time()
for _ in range(3):
   new_thread = Thread(target=do_something, args=[1])
   executables.append(new_thread)
   new_thread.start()

for t in executables:
  t.join()



end=time.time()

print( f'Tempo decorrido:{end-start}')

# Código para processo
import time
import multiprocessing
# função a ser executada tanto pela tread quanto pelo processo
def do_something(sec):
  print('Doing Something...')
  time.sleep(sec)
  print('Done!')

executables=[]
start=time.time()
for _ in range(3):
  new_process = multiprocessing.Process(target=do_something, args=([1]))
  new_process.start()
  executables.append(new_process)

for t in executables:
  t.join()



end=time.time()

print( f'Tempo decorrido:{end-start}')

"""# *  3.B Usando o Process Pool*#
Vamos usar a abstração Process pool
"""

from multiprocessing import Pool
import os

def worker_function(x):
    pid = os.getpid()
    return f"Processing {x} in process {pid}"

if __name__ == '__main__':
    with Pool(processes=4) as pool:
        results = pool.map(worker_function, range(10))
        for result in results:
            print(result)