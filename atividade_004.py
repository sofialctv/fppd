# -*- coding: utf-8 -*-
"""FPPD_04.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zgDPFUisLgLhZF-UB5Vwl5M_NLKGsC_w

# *Instruções*


1.  Verifique se sua máquina tem o interpretador Python Instalado
2.  Verifique quantos núcleos físicos sua máquina possui
  * Windows:  https://support.microsoft.com/pt-br/windowsdescobrir-quantos-n%C3%BAcleos-o-processador-tem-3126ef99-0247-33b3-81fc-065e9fb0c35b#:~:text=Pressione%20Ctrl%20%2B%20Shift%20%2B%20ESC%20para,processadores%20l%C3%B3gicos%20seu%20computador%20tem.

  * Linux : https://tecnoblog.net/responde/como-ver-quantos-nucleos-tem-a-cpu/#:~:text=Paulo%20Higa%2FTecnoblog)-,Qual%20comando%20digitar%20para%20ver%20o%20n%C3%BAmero%20de%20n%C3%BAcleos%20de,(s)%20por%20soquete%E2%80%9D.



3. rode todos os códigos sugeridos em sua máquina física

# *Atividade 1*

Vamos Experimentar e verificar a Lei de Amdhal

Speedup= T1/Tn,  onde  T1 é o tempo de execução do algoritmo  em um único processador e Tn é o tempo para n processadores

O problema a ser utilizado no experimento é a ordenação de um vetor com 100.000 números inteiros

# **1.A**
Usando o algorítmo da bolha (bubble sort) https://youtu.be/8RkZoBZNNgI
Crie a Versão que usa um processador único
"""

import time
import numpy as np
#
N=100000
vetor=np.random.randint(0, high=None, size=N, dtype=int)

#Não se esqueça de medir o tempo de processamento
start=time.time()

### crie seu código Aqui



end=time.time()

print( f'Tempo decorrido:{end-start}')

"""# *1.B*
Usando o algorítmo da bolha (bubble sort)  Crie a Versão que usa ao menos 2 processadore (dois processos)
"""

# importing the multiprocessing module
import multiprocessing
import os
import time
import numpy as np

def task(array):
# repetir o código do bubble sort aqui

if __name__ == "__main__":
	Size=100000
 vetor=np.random.randint(0, high=None, size=Size, dtype=int)
 ctype = np.ctypeslib.as_ctypes(vetor)
    # create ctype array initialized from our array
  array = multiprocessing.Array(ctype._type_, vetor, lock=False)
  start=time.time()
	# creating new process
	p1 = multiprocessing.Process(target=task, args=(array[0:len(array)//2],))
	# starting process
	p1.start()
	# wait until process is finished
	p1.join()
  p2 = multiprocessing.Process(target=task, args=(array[len(array)//2+1:],))
	# starting process
	p2.start()
	# wait until process is finished
	p2.join()
	# passada final do algoritmo
	task(array)
  end=time.time()
  print( f'Tempo decorrido:{end-start}')

  print("Resultado:",array)

"""Atividade 2
Vamos Experimentar e verificar a Lei de Gustafson-Barsis
 Que propõe que o speedup escala  de forma proporcional ao tamanho do problema



O problema a ser utilizado no experimento é a ordenação de um vetor com números inteiros:

Partindo dos 100.000  iniciais, vamos usar o fator N=[2,3,4,5] para criar  vetores , respectivamente com o dobro do tamanho original, depois com o triplo, assim sucesivamente.
"""

# usar aqui o código da Atividade 1.B Criando tantos processos quanto a quantidade de núcleos do seu computador
 # lembre-se de dividir o vetor igualmente entre os processos